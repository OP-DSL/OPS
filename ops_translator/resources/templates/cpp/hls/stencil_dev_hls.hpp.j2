{% macro chainLinkTranform(link) -%}
{%- if link is isnumaric -%}
stencilValues[{{link}}]
{%- elif "buf_r" in link -%}
{{link}}[i_l]
{%- elif "buf_p" in link -%}
{{link}}[i_p]
{%- else -%}
{{link}}
{%- endif -%}
{%- endmacro -%}

{%set half_span_x = (stencil.stencil_size - 1) / 2%}
{% block header_block %}
#pragma onece

#include <common_config.hpp>
#include <ops_hls_stencil_core.hpp>

static constexpr unsigned short {{stencil.stencil_ptr}}_num_points = {{stencil.num_points}};
static constexpr unsigned short {{stencil.stencil_ptr}}_stencil_size = {{stencil.stencil_size}};
static constexpr unsigned short {{stencil.stencil_ptr}}_stencil_dim = {{stencil.dim}};
{% endblock %}

class {{stencil.stencil_ptr}} : public ops::hls::StencilCore <stencil_type, {{stencil.stencil_ptr}}_num_points,
        vector_factor, ops::hls::CoefTypes::CONST_COEF, {{stencil.stencil_ptr}}_stencil_size,
        {{stencil.stencil_ptr}}_stencil_dim>
{
public:
    using ops::hls::StencilCore <stencil_type, {{stencil.stencil_ptr}}_num_points,
    vector_factor, ops::hls::CoefTypes::CONST_COEF, {{stencil.stencil_ptr}}_stencil_size,
        {{stencil.stencil_ptr}}_stencil_dim>::m_gridProp;

    void stencilRead(widen_stream_dt& rd_buffer,
{% for i in range(stencil.num_points) %}
            ::hls::stream<stencil_type> output_bus_{{i}}[vector_factor]{{"," if not loop.last}}
{% endfor %}
            )
    {
        unsigned short i = 0; 
{% if stencil.dim > 1 %}
        unsigned i_l = 0; // Line buffer index
        unsigned short j = 0; 
{% endif %}
{% if stencil.dim > 2 %}
        unsigned i_p = 0; // Plane buffer index
        unsigned short k = 0;
{% endif %}

        ::ops::hls::GridPropertyCore gridProp = m_gridProp;
{% if stencil.dim  == 1 %}
        unsigned short itr_limit = gridProp.total_itr;
{% elif stencil.dim == 2%}
        unsigned short itr_limit = gridProp.outer_loop_limit * gridProp.xblocks;
{% else %}
        unsigned short itr_limit = gridProp.outer_loop_limit * 
                gridProp.grid_size[1] * gridProp.xblocks;
{% endif %}
        unsigned short act_total_itr = gridProp.total_itr;
        widen_dt read_val = 0;
            
        widen_dt stencilValues[{{stencil.stencil_ptr}}_num_points];
        #pragma HLS ARRAY_PARTITION variable = stencilValues dim = 1 complete

{% for buffer in stencil.window_buffers %}
        widen_dt {{buffer}}[max_depth_bytes/(sizeof(stencil_type) * vector_factor)];
        #pragma HLS BIND_STORAGE variable =  {{buffer}} type = ram_t2p impl=uram latency=2
{% endfor %}

{% for row_discriptor in stencil.row_discriptors %}
        stencil_type rowArr_{{row_discriptor.row_id[0]}}_{{row_discriptor.row_id[1]}}[vector_factor + s_stencil_span_x];
        #pragma HLS ARRAY_PARTITION variable = rowArr_{{row_discriptor.row_id[0]}}_{{row_discriptor.row_id[1]}} dim=1 complete
{% endfor %}

        for (unsigned short itr = 0; itr < itr_limit; itr++)
        {
        #pragma HLS PIPELINE II=1

            spc_temp_blocking_read:
            {
                bool cond_x_terminate = (i == gridProp.xblocks - 1); 
{% if stencil.dim == 2 %}
                bool cond_y_terminate = (j == gridProp.outer_loop_limit - 1);
{% elif stenicl.dim == 3 %}
                bool cond_y_terminate = (j == gridProp.grid_size[1] - 1);
                bool cond_z_terminate = (k == gridProp.outer_loop_limit - 1);
{% endif %}

                if (cond_x_terminate)
                    i = 0;
                else
                    i++;
{% if stencil.dim == 2 %}
                if (cond_x_terminate && cond_y_terminate)
                    j = 0;
                else if (cond_x_terminate)
                    j++;
{% elif stenicl.dim == 3 %}
                if (cond_x_terminate && cond_y_terminate && cond_z_terminate)
                    k = 0;
                else if (cond_x_terminate && cond_y_terminate)
                    k++
{% endif %}

                bool cond_read = (itr < act_total_itr);

                if (cond_read)
                    read_val = rd_buffer.read();

{% for chain in stencil.chains %}
                {{chainLinkTranform(chain[0])}} = {{chainLinkTranform(chain[1])}};
{% endfor %}
            
{# This need to be improved with adding new clear atributes to gridProp #}
{% if stencil.dim > 1 %}
                bool cond_end_of_line_buff = (i_l) >= (gridProp.xblocks - 1);
{% endif %}
{% if stencil.dim > 2 %}
                bool cond_end_of_plane_buff = (i_p) >= (gridProp.plane_diff);
{% endif %}

{% if stencil.dim > 1 %}
                if (cond_end_of_line_buff)
                    i_l = 0;
                else
                    i_l++;
{% endif %}
{% if stencil.dim > 2 %}
                if (cond_end_of_plane_buff)
                    i_p = 0;
                else
                    i_p++;
{% endif %}

#ifdef DEBUG_LOG
                printf("[DEBUG][INTERNAL] loop params i(%d), j(%d),"\
{% if stencil.dim > 1 %}
                        "i_l(%d), "\
{% endif %}
{% if stencil.dim > 2 %}
                        "i_p(%d), "\
{% endif %}
                        "itr(%d)\n", i, j,
{% if stencil.dim > 1 %} 
                        i_l,
{% endif %}
{% if stencil.dim > 2 %}
                        i_p,
{% endif %}
                        itr);
                printf("[DEBUG][INTERNAL] --------------------------------------------------------\n\n");

                printf("[DEBUG][INTERNAL] read values: (");
                for (int ri = 0; ri < vector_factor; ri++)
                {
                    ops::hls::DataConv tmpConverter;
                    tmpConverter.i = read_val.range((ri + 1)*s_datatype_size - 1, ri * s_datatype_size);
                    printf("%f ", tmpConverter.f);
                }
                printf(")\n");
#endif

            }

            vec2arr: for (unsigned short x = 0; x < vector_factor; x++)
            {
{% for row_discriptor in stencil.row_discriptors %}
    {% for point in row_discriptor.row_points %}
        {% if point.x == row_discriptor.base_point.x %}
                ops::hls::DataConv tmpConverter_{{point.y}}_{{point.z}};
                tmpConverter_{{point.y}}_{{point.z}}.i = stencilValues[{{stencil.points.index(point)}}](s_datatype_size * (x + 1) - 1, x * s_datatype_size);
                rowArr_{{row_discriptor.row_id[0]}}_{{row_discriptor.row_id[1]}}[x + s_stencil_half_span_x] = tmpConverter_{{point.y}}_{{point.z}}.f; 
        {% endif %}
    {% endfor %}
{% endfor %}
            }

{% for row_discriptor in stencil.row_discriptors %}
    {% for point in row_discriptor.row_points %}
        {% if point.x != row_discriptor.base_point.x %}
            {% for i in range(config.vector_factor) %}
                {% set diff = point.x - row_discriptor.base_point.x %}
                {% set access_idx = diff * config.vector_factor + row_discriptor.base_point.x + i %}
                {% if (diff < 0 and access_idx >= 0) or (diff > 0 and access_idx <= config.vector_factor + 2 * half_span_x) %}
            ops::hls::DataConv tmpConverter_{{point.x}}_{{point.y}}_{{point.z}}_{{i}};
            tmpConverter_{{point.x}}_{{point.y}}_{{point.z}}_{{i}}.i = stencilValues[{{stencil.points.index(point)}}].range(s_datatype_size * (i + 1) - 1, s_datatype_size * i);
            rowArr_{{row_discriptor.row_id[0]}}_{{row_discriptor.row_id[1]}}[{{access_idx}}] = tmpConverter_{{point.x}}_{{point.y}}_{{point.z}}_{{i}}.f;
                {% endif %}
            {% endfor %}
        {% endif %}
    {% endfor %}
{% endfor %}

            process: for(unsigned short x = 0; x < vector_factor; x++)
            {
{% for i in range(stencil.num_points) %}
                output_bus_{{i}}[x].write(rowArr_{{stencil.points[i].y}}_{{stencil.points[i].z}}[x + {{stencil.points[i].x}}]);
{% endfor %}               
            }
        }
    }

{% if stencil.num_points == 1 %}
    void stencilWrite(widen_stream_dt& wr_buffer,
            mask_stream_dt& strb_buffer,
            ::hls::stream<stencil_type> input_bus[vector_factor])
    {
        unsigned short i = 0; 
    {% if stencil.dim > 1 %}
        unsigned i_l = 0; // Line buffer index
        unsigned short j = 0; 
    {% endif %}
    {% if stencil.dim > 2 %}
        unsigned i_p = 0; // Plane buffer index
        unsigned short k = 0;
    {% endif %}

        ::ops::hls::GridPropertyCore gridProp = m_gridProp;
    {% if stencil.dim  == 1 %}
        unsigned short itr_limit = gridProp.total_itr;
    {% elif stencil.dim == 2%}
        unsigned short itr_limit = gridProp.outer_loop_limit * gridProp.xblocks;
    {% else %}
        unsigned short itr_limit = gridProp.outer_loop_limit * 
                gridProp.grid_size[1] * gridProp.xblocks;
    {% endif %}
        widen_dt updateValue;
        mask_dt maskValue;

        for (unsigned short itr = 0; itr < itr_limit; itr++)
        {
        //#pragma HLS LOOP_TRIPCOUNT min=min_grid_size max=max_grid_size avg=avg_grid_size
        #pragma HLS PIPELINE II=1

            spc_blocking:
            {
                bool cond_x_terminate = (i == gridProp.xblocks - 1); 
    {% if stencil.dim == 2 %}
                bool cond_y_terminate = (j == gridProp.outer_loop_limit - 1);
    {% elif stenicl.dim == 3 %}
                bool cond_y_terminate = (j == gridProp.grid_size[1] - 1);
                bool cond_z_terminate = (k == gridProp.outer_loop_limit - 1);
    {% endif %}
                if (cond_x_terminate)
                    i = 0;
                else
                    i++;

    {% if stencil.dim == 2 %}
                if (cond_x_terminate && cond_y_terminate)
                    j = 0;
                else if (cond_x_terminate)
                    j++;
    {% elif stenicl.dim == 3 %}
                if (cond_x_terminate && cond_y_terminate && cond_z_terminate)
                    k = 0;
                else if (cond_x_terminate && cond_y_terminate)
                    k++
    {% endif %}

{# This need to be improved with adding new clear atributes to gridProp #}
{% if stencil.dim > 1 %}
                bool cond_end_of_line_buff = (i_l) >= (gridProp.xblocks - 1);
{% endif %}
{% if stencil.dim > 2 %}
                bool cond_end_of_plane_buff = (i_p) >= (gridProp.plane_diff);
{% endif %}

    {% if stencil.dim > 1 %}
                if (cond_end_of_line_buff)
                    i_l = 0;
                else
                    i_l++;
    {% endif %}
    {% if stencil.dim > 2 %}
                if (cond_end_of_plane_buff)
                    i_p = 0;
                else
                    i_p++;
    {% endif %}
            }
                            
            process_read: for (unsigned short x = 0; x < vector_factor; x++)
            {  
#pragma HLS UNROLL complete
                unsigned short index = (i << shift_bits) + x;
                bool cond_no_point_update = register_it((index < m_lowerLimits[0])
                        || (index >= m_upperLimits[0])
    {% if stencil.dim == 2 %}
                        || (j < (m_lowerLimits[1] + s_stencil_half_span_x))
                        || (j >= (m_upperLimits[1] + s_stencil_half_span_x)));
    {% else %}
                        || (j < m_lowerLimits[1])
                        || (j >= m_upperLimits[1])
                        || (k < (m_lowerLimits[2] + s_stencil_half_span_x))
                        || (k >= (m_upperLimits[2] + s_stencil_half_span_x)));        
    {% endif %}
                ops::hls::DataConv tmpConv;
                stencil_type r = input_bus[x].read();
                tmpConv.f = r;
#ifdef DEBUG_LOG
    {% if stencil.dim == 1 %}
                printf("[KERNEL_DEBUG]|%s| reading, (i:%d, vec_idx:%d), limits(xl:>= %d, xh:< %d), stencil_half_span: %d, value:%f, condition_update:%d\n",
                        __func__, i, x, m_lowerLimits[0], m_upperLimits[0], s_stencil_half_span_x, r, cond_no_point_update);
    {% elif stencil.dim == 2 %}
                printf("[KERNEL_DEBUG]|%s| reading, (i:%d, j:%d, vec_idx:%d), limits(xl:>= %d, xh:< %d, yl:>= %d, yh:< %d), stencil_half_span: %d, value:%f, condition_update:%d\n",
                        __func__, i, j, x, m_lowerLimits[0], m_upperLimits[0], (m_lowerLimits[1] + s_stencil_half_span_x), (m_upperLimits[1] + s_stencil_half_span_x), s_stencil_half_span_x, r, cond_no_point_update);
    {% else %}
                printf("[KERNEL_DEBUG]|%s| reading, (i:%d, j:%d, k:%d, vec_idx:%d), limits(xl:>= %d, xh:< %d, yl:>= %d, yh:< %d, zl:>= %d, zh:< %d), stencil_half_span: %d, value:%f, condition_update:%d\n",
                        __func__, i, j, k, x, m_lowerLimits[0], m_upperLimits[0], m_lowerLimits[1], m_upperLimits[1], (m_lowerLimits[2] + s_stencil_half_span_x), (m_upperLimits[2] + s_stencil_half_span_x), s_stencil_half_span_x, r, cond_no_point_update);
    {% endif %}
#endif
                if (cond_no_point_update)
                {
                        maskValue.range((x + 1) * sizeof(stencil_type) - 1, x * sizeof(stencil_type)) = 0;
                        updateValue.range(s_datatype_size * (x + 1) - 1, x * s_datatype_size) = 0.123456789; //To spot errors this value is given
                }
                else
                {
                    maskValue.range((x + 1) * sizeof(stencil_type) - 1, x * sizeof(stencil_type)) = -1;
                    updateValue.range(s_datatype_size * (x + 1) - 1, x * s_datatype_size) = tmpConv.i;
                }
            }

            write:
            {
                //ool cond_write = (j >= 0);

                //if (cond_write)
                //{
#ifdef DEBUG_LOG
    {% if stencil.dim == 1 %}
                    printf("[KERNEL_DEBUG]|%s| writing to axis. (i:%d), val=(", __func__, i);
    {% elif stencil.dim == 2 %}
                    printf("[KERNEL_DEBUG]|%s| writing to axis. (i:%d, j:%d), val=(", __func__, i, j);
    {% else %}
                    printf("[KERNEL_DEBUG]|%s| writing to axis. (i:%d, j:%d, k:%d), val=(", __func__, i, j, k);

    {% endif %}
                    for (unsigned short x = 0; x < vector_factor; x++)
                    {
                        ops::hls::DataConv tmp;
                        tmp.i = updateValue.range(s_datatype_size * (x + 1) - 1, x * s_datatype_size);
                        printf("%f,", tmp.f);
                    }
                    printf(")\n");
#endif
                    wr_buffer << updateValue;
                    strb_buffer << maskValue;
                //}
            }
        }
#ifdef DEBUG_LOG
        printf("[KERNEL_DEBUG]|%s| exiting.", __func__);
#endif        
    }
{% endif %}
};
